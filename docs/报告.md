# 使用MVC、MVP、MVVM和FRP实现Android局域网群聊应用

| 姓名      | 学号   |
| --------- | ------ |
| 161250010 | 陈俊达 |
| 161250002 | 蔡蔚霖 |
| 161250060 | 李培林 |
| 161250199 | 张凌哲 |

# 1. 简介

在本报告中，我们使用MVC、MVP、MVVM和FRP分别实现了一个Android局域网群聊应用，并通过分析在使用这四个架构实现应用功能的过程中每个架构所表现出的特点，来分析每个架构自身的优点和缺点。

# 2. 项目说明

项目地址：https://github.com/viccrubs/android-chat-in-4-patterns

项目可直接使用Android Studio打开，需注意Android Studio应安装有lombok插件（[安装教程](https://projectlombok.org/setup/android#android-studio)）。本项目分为3个模块 ：app, server, shared。三个模块的说明如下表：
 
| 模块     | 作用                       | 启动方式                                      |
| -------- | -------------------------- | --------------------------------------------- |
| `app`    | Android应用部分            | 使用模拟器或者实机打开                        |
| `server` | 聊天服务器端               | 直接运行`nju.androidchat.server.ChatServer`类 |
| `shared` | 包含有服务端和客户端公用类 | 不启动                                        |

## 2.1 应用需求

为了展示各个架构在实现功能的过程中的特点，我们将需求分成**基础需求**和**扩展需求**。

### 2.1.1 基本需求

服务器

1.	建立与多个客户端的连接
2.	接受任何一个已连接的客户端发送的消息，并发送到其他所有客户端

客户端

1.	发起到服务器的连接
2.	接受用户输入文字信息
3.	发送文字信息到服务器
4.	接受服务器文字信息并显示

### 2.1.2 扩展需求

| 功能编号 | 实现的功能点简介       | 功能详细介绍                                                                                                                             | 使用架构 | 使用本架构的代码实现                                                                                                                              | 相对于上一个架构的优点                                         | 使用此架构实现本需求点的不足之处                                                                                                                                         | 更好的架构 | 更好的实现                                                                                                                                                                                                            |
| -------- | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1        | 增加消息记录云备份功能 | 增加一个界面，界面中有一个按钮，点击按钮后将本地的消息记录发送到某个云服务器                                                             | MVC      | 增加一个Activity，Activity连接一个Controller。当用户点击备份按钮后，Activity将备份请求转发给C，C转发给M，M发起网络请求，且在结束后通知V修改界面。 |                                                                | 当按下按钮后View无法及时响应（M还在等待响应，没有通知V数据变化）                                                                                                         | MVP        | P能够控制V（对比C不能控制V），所以当V（Activity）将备份请求给P时，P可以控制V进行及时的、恰当的显示（比如显示备份中字样）                                                                                              |
| 2        | 撤回消息               | 某个客户端的用户选择一条消息撤回（只能是自己发的消息），其他用户的客户端上，如果该消息存在于浏览页面，这一消息会被置换为“该消息已被撤回” | MVP      | 在P和V中都增加处理逻辑，P中当接受到撤回消息的请求时，调用V的撤回消息方法；V的响应方法中，将对应消息文本框的text设置成“已撤回”                     |                                                                | 需要同时修改P和V。当业务逻辑复杂时（例如说一个消息可能具有很多状态（撤回也可以考虑成一个消息的状态）每个状态都需要在UI上进行特殊显示时），P和V可能需要增加很多处理函数。 | MVVM       | 将消息状态和界面进行双向绑定，修改消息ViewModel的状态就会同时更改界面中对象消息的状态，不需要单独的逻辑处理。同时也可以把界面上的输入框和某个属性进行双向绑定，减少UI事件处理的代码。（这个其实可以算一个单独的功能） |
| 3        | 过滤脏话               | 当客户端接受到信息时，根据预设的脏话列表（表现为正则表达式数组）匹配信息内容，如果匹配到信息里包含脏话，则信息修改为***                  | MVVM     | 修改在VM和UI组件的绑定处理函数中（就是，当VM改变时UI应该怎么改变），增加判断逻辑。若包含脏话，则将显示的信息设置为***                             |                                                                | 需要修改逻辑。若逻辑更加复杂，则可能使此绑定函数过于冗长，难以维护。                                                                                                     | FRP        | 将接受到的信息看作一个流，增加判断逻辑只是在这个流上增加过滤函数而已；增加逻辑也只需要增加过滤函数而不是修改已有逻辑                                                                                                  |
| 4        | 限制用户发送消息频率   | 限制用户在1s中只能发出一条信息，消息发送后1s内不允许发送。                                                                               | FRP      | 将用户发送信息也考虑为一个流，使用throttle对发送消息函数进行节流                                                                                  | 只需要增加流处理函数，不需要修改已有逻辑，也不需要手动写计时器 |                                                                                                                                                                          |            |                                                                                                                                                                                                                       |


## 2.2 实现说明

1. 使用Java语言
2. 所有客户端和服务器运行在同一台机器，使用Socket通信

在实际实现中，我们将采用以下形式：
1. 首先使用MVC，MVP，MVVM和FRP四种架构分别实现基础需求
    - 初始设计中考虑所有功能点的前置条件
        1. 功能1：客户端本地已经保存消息记录
        2. 功能2：需要项目配好junit，MVP中P对M和V应该是依赖接口，而不是依赖具体类
        1. 功能3：需要区分不同的请求类型；每个接受到的信息可以独立修改
        1. 功能4：倒是没有特殊的前置条件
        1. 功能5：倒是没有特殊的前置条件。
        1. 作业1：每个接受的的信息用单独的容器显示，而不是在一个TextBox里修改其文本（和功能3比较类似）
        1. 作业2：同上
        1. 作业3：这个让他们自己改吧
2.	复制1次MVC的原始代码（称为MVP-0），在复制的MVC代码中实现功能1
    1. 实现了功能1的MVC代码编号为代码MVC-1
3.	复制2次MVP的原始代码（MVP-0），在第一份MVP代码中实现功能1，第二份实现功能2
    1. 实现了功能1的MVP代码编号为代码MVP-1，和MVC-1形成对照
    1. 实现了功能2的MVP代码编号为代码MVP-2
4.	复制2次MVVM的原始代码（MVVM-0），在第一份代码中实现功能2，在第二份代码中实现功能3
    1. 实现功能2的MVVM代码编号为代码MVVM-2，和MVP-2形成对照
    1. 实现功能3的MVVM代码编号为代码MVVM-3
5.	复制2次FRP的原始代码（FRP-0），在第一份代码中实现功能3，第二份代码中实现功能4
    1. 实现了功能4的FRP代码编号为FRP-3，和MVVM-3对照
    1. 实现了功能5的FRP代码编号为FRP-4

## 2.3 应用使用

系统使用配置文件确定**在登录后要进入哪个Activity**（称为**目标Activity**）。

要修改登录后进入哪个窗口，修改`app/assets/config.properties`文件中`chat_activity`为对应的类名。可选的类名有如下格式：
> `nju.androidchat.client.{架构: Mvc|Mvp|Mvvm|Frp}{编号: 1|2|3|4}.{架构: Mvc|Mvp|Mvvm|Frp}{编号: 1|2|3|4}TalkActivity`
 
例如：要进入之上提到的**实现了功能3的MVVM代码**，应将其修改为

> `nju.androidchat.client.mvvm3.Mvvm3TalkActivity`

要启动应用，设置好**目标Activity**后，应首先启动Server。等Server启动完成后（显示下图的字样即启动完成），再使用Android Studio运行多个客户端。

![](./img/server-launched.png)

当客户端启动成功后，输入用户名后点击登录按钮进行登录。要注意多个客户端不能使用同一个用户名，否则登录时将会报错。

![](./img/client-input-username.png)

进入主界面后，输入信息点击发送即可将信息发送出去。本机发出的信息显示在右边，其他用户发送的信息显示在左边。

![](./img/client-chat-main.png)

通过修改**目标Activity**，可以尝试各个功能的效果。各个功能的效果gif图可以在下文介绍实现每个功能时看到。

# 3. Android代码和界面交互

首先，我们得搞清楚在Android中，逻辑代码是如何与界面进行交互的。

在Android中，逻辑通过**Java代码**进行编写，而界面中的元素通过**XML**进行定义。在Java代码中，可以通过**findViewById**方法，找到某个元素对应的对象，并进行操作。

例如说，以下XML代码在界面中定义了一个`EditText`组件，并通过`android:id`属性定义其ID为`et_content`。

app\res\layout\activity_main.xml, 57-68

```xml
<EditText
    android:id="@+id/et_content"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/message_shap_chat_bg"
    android:imeOptions="actionSend"
    android:maxLines="1"
    android:minHeight="36dp"
    android:paddingStart="13dp"
    android:textSize="13sp"
    />
```

这样，在代码中，我们就可以通过`findViewById(R.id.et_content)`获得此控件的实例，并进行交互（例如订阅事件功能）。

app\src\main\java\nju\androidchat\client\mvc0\Mvc0TalkActivity.java, 43-45

```java
// Input事件处理
EditText editText = findViewById(R.id.et_content);
editText.setOnEditorActionListener(this);
```

在代码中也可以通过直接实例化控件的实例，来生成一个新的界面元素，并通过其他控件暴露的方法（例如说`LinearLayout`提供的`addView`方法）将新生成的界面元素增加到界面中。

app\src\main\java\nju\androidchat\client\mvc0\Mvc0TalkActivity.java, 57-71

```java
LinearLayout content = findViewById(R.id.chat_content);

// 删除所有已有的ItemText
content.removeAllViews();

// 增加ItemText
for (ClientMessage message: messages) {
    String text = String.format("%s", message.getMessage());
    // 如果是自己发的，增加ItemTextSend，并传入撤回请求事件处理
    if (message.getSenderUsername().equals(model.getUsername())) {
        content.addView(new ItemTextSend(this, text, message.getMessageId(), this));
    } else {
        content.addView(new ItemTextReceive(this, text, message.getMessageId()));
    }
}

```

这样，我们实现了代码和界面的交互操作。

## 3.1 一个Activity的职责

一个典型的Activity需要负责以下两个部分的工作：
- 处理界面中的事件（例如上面处理的`EditText`的`onEditorAction`事件）
- 业务逻辑的操作。

app\src\main\java\nju\androidchat\client\mvc0\Mvc0TalkActivity.java, 115-118

```java
// 界面操作：发送按钮点击事件处理
public void onBtnSendClicked(View v) {
    // 界面操作，隐藏键盘
    hideKeyboard();
    
    // 业务逻辑操作，发送文本
    sendText();
}
```

## 3.2 问题

如果我们把所有的事件处理代码和业务逻辑操作都堆在Activity中，很容易就造成Activity的代码堆积。

为了解决这个问题，人们提供出了Model-View-Controller架构，即MVC架构。

# 4. MVC架构

## 4.1 介绍

![](./img/mvc1.png)

在MVC架构中，**界面相关的代码**和**业务逻辑相关的代码**被分开，分别放在View和Model中。而在Android开发中，View即我们之前提到的Activity。他们三者之间的关系如上图所示，即

- Model负责维护业务模型数据，并进行实际的业务逻辑操作
- View通过观察者模式，从Model中获得数据并订阅其中的数据变化；View要进行事件处理时，通过Controller进行中转。
- Controller将会负责多个View之间的跳转，以及将View层的数据请求转发到Model中。

具体来说，如果我们通过MVC架构实现发送消息这个功能，其数据流应该如下图所示。其中，左边（后缀为1的MVC）为发送者，右边（后缀为2的MVC）为接收者。

![](img/mvc-send-dataflow.png)

通过这样，

- 界面代码和业务逻辑代码被分离，避免了Activity代码爆炸
- 各个部分也能独立修改，展示的修改不影响业务逻辑部分的代码

## 4.2 问题

根据MVC的数据流图，我们应该注意到一个问题：**界面控制不灵活**。

在传统MVC中，V只能因为M变化而变化（C只能控制V的跳转）。当M的操作**很快**就能完成的时候，V也能很快获得响应；但是如果M的操作**不能很快完成（异步操作，耗时操作）呢？**

## 4.3 扩展功能1：消息备份

我们尝试使用MVC架构实现扩展功能1：消息备份。

![](img/extfunc1.gif)

消息备份是一个全新的界面，在这个界面中，上面有一个大按钮**备份**。当点击备份后，系统将会发送一个异步HTTP请求（在真正的实现中，用Thread.sleep）代替。在请求进行中，View的界面请求结束后，将会在界面中显示上次更新时间。

根据MVC架构，我们可以很容易地画出如下的数据流图。

![](img/mvc-backup-dataflow.png)

看起来非常的正常，但是我们思考一个问题：**当Model正在进行3. 备份操作时，View如何进行响应？**

就像我们之前所说的，在MVC中V的改变只能由M引起。但是当M没有被修改时，V如何进行改变？

你可能会说：我们可以将此“正在备份”的状态**也考虑为一种数据**，然后在Model中，在发起HTTP请求之前，我们先修改这个**数据**，引发View改变。根据这个思路的代码实现可以参考代码中`mvc1`下的`Mvc1Backup(Activity|Controller|Model)`三个类，在报告中就不再赘述。

这样的实现的问题在于：

> 这个“正在备份”的数据**和界面相关**，却放在了**应该只处理业务逻辑的Model中**。
 
我们再次把界面和业务逻辑耦合在了一起，

